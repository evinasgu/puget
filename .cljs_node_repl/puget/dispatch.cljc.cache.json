["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$puget.dispatch","~:imports",null,"~:requires",["^ ","~$str","~$clojure.string","^=","^=","~$gstring","~$goog.string","^?","^?"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$chained-lookup",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","~:line",14,"~:column",7,"~:end-line",14,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^L",[["~$dispatchers"],["~$a","~$b","~$&","~$more"]]]]],"~:doc","Builds a dispatcher which looks up a type by checking multiple dispatchers\n  in order until a matching entry is found. Takes either a single collection of\n  dispatchers or a variable list of dispatcher arguments. Ignores nil\n  dispatchers in the sequence.","~:top-fn",["^ ","~:variadic?",true,"~:fixed-arity",2,"~:max-fixed-arity",2,"~:method-params",["^L",[["^N"]]],"^K",["^L",[["^N"],["~$a","~$b","~$&","^O"]]],"~:arglists-meta",["^L",[null,null]]]],"^8","~$puget.dispatch/chained-lookup","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^J",21,"^Q",["^ ","^R",true,"^S",2,"^T",2,"^U",["^L",[["^N"]]],"^K",["^L",[["^N"],["~$a","~$b","~$&","^O"]]],"^V",["^L",[null,null]]],"^U",["^L",[["^N"]]],"~:protocol-impl",null,"^S",2,"^V",["^L",[null,null]],"^H",1,"^R",true,"~:methods",[["^ ","^S",1,"^R",false,"~:tag",["^7",["~$any","~$function","~$clj-nil"]]],["^ ","^S",2,"^R",true,"^Z",["^7",["^[","^10","^11"]]]],"^G",14,"^I",14,"^T",2,"~:fn-var",true,"^K",["^L",[["^N"],["~$a","~$b","~$&","^O"]]],"^P","Builds a dispatcher which looks up a type by checking multiple dispatchers\n  in order until a matching entry is found. Takes either a single collection of\n  dispatchers or a variable list of dispatcher arguments. Ignores nil\n  dispatchers in the sequence."],"~$caching-lookup",["^ ","^D",null,"^E",["^ ","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^G",35,"^H",7,"^I",35,"^J",21,"^K",["^L",["^M",["^L",[["~$dispatch"]]]]],"^P","Builds a dispatcher which caches values returned for each type. This improves\n  performance when the underlying dispatcher may need to perform complex\n  lookup logic to determine the dispatched value."],"^8","~$puget.dispatch/caching-lookup","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^J",21,"^U",["^L",[["^14"]]],"^X",null,"^V",["^L",[null,null]],"^H",1,"^R",false,"^G",35,"~:ret-tag","^10","^I",35,"^T",1,"^12",true,"^K",["^L",["^M",["^L",[["^14"]]]]],"^P","Builds a dispatcher which caches values returned for each type. This improves\n  performance when the underlying dispatcher may need to perform complex\n  lookup logic to determine the dispatched value."],"~$symbolic-lookup",["^ ","^D",null,"^E",["^ ","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^G",53,"^H",7,"^I",53,"^J",22,"^K",["^L",["^M",["^L",[["^14"]]]]],"^P","Builds a dispatcher which looks up a type by checking the underlying lookup\n  using the type's _symbolic_ name, rather than the class value itself. This is\n  useful for checking configuration that must be created in situations where the\n  classes themselves may not be loaded yet."],"^8","~$puget.dispatch/symbolic-lookup","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^J",22,"^U",["^L",[["^14"]]],"^X",null,"^V",["^L",[null,null]],"^H",1,"^R",false,"^G",53,"^16","^10","^I",53,"^T",1,"^12",true,"^K",["^L",["^M",["^L",[["^14"]]]]],"^P","Builds a dispatcher which looks up a type by checking the underlying lookup\n  using the type's _symbolic_ name, rather than the class value itself. This is\n  useful for checking configuration that must be created in situations where the\n  classes themselves may not be loaded yet."],"~$lineage",["^ ","^D",null,"^E",["^ ","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^G",64,"^H",8,"^I",64,"^J",15,"~:private",true,"^K",["^L",["^M",["^L",[["~$cls"]]]]],"^P","Returns the ancestry of the given class, starting with the class and\n  excluding the `java.lang.Object` base class."],"^1:",true,"^8","~$puget.dispatch/lineage","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^J",15,"^U",["^L",[["^1;"]]],"^X",null,"^V",["^L",[null,null]],"^H",1,"^R",false,"^G",64,"^16","~$cljs.core/LazySeq","^I",64,"^T",1,"^12",true,"^K",["^L",["^M",["^L",[["^1;"]]]]],"^P","Returns the ancestry of the given class, starting with the class and\n  excluding the `java.lang.Object` base class."],"~$find-interfaces",["^ ","^D",null,"^E",["^ ","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^G",72,"^H",8,"^I",72,"^J",23,"^1:",true,"^K",["^L",["^M",["^L",[["^1;"]]]]],"^P","Resolves all of the interfaces implemented by a class, both direct (through\n  class ancestors) and indirect (through other interfaces)."],"^1:",true,"^8","~$puget.dispatch/find-interfaces","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^J",23,"^U",["^L",[["^1;"]]],"^X",null,"^V",["^L",[null,null]],"^H",1,"^R",false,"^G",72,"^16",["^7",["~$clj","~$cljs.core/ISet"]],"^I",72,"^T",1,"^12",true,"^K",["^L",["^M",["^L",[["^1;"]]]]],"^P","Resolves all of the interfaces implemented by a class, both direct (through\n  class ancestors) and indirect (through other interfaces)."],"~$inheritance-lookup",["^ ","^D",null,"^E",["^ ","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^G",88,"^H",7,"^I",88,"^J",25,"^K",["^L",["^M",["^L",[["^14"]]]]],"^P","Builds a dispatcher which looks up a type by looking up the type itself,\n  then attempting to look up its ancestor classes, implemented interfaces, and\n  finally `java.lang.Object`."],"^8","~$puget.dispatch/inheritance-lookup","^F","/home/enyert/Projects/gaiwan/puget/src/puget/dispatch.cljc","^J",25,"^U",["^L",[["^14"]]],"^X",null,"^V",["^L",[null,null]],"^H",1,"^R",false,"^G",88,"^16","^10","^I",88,"^T",1,"^12",true,"^K",["^L",["^M",["^L",[["^14"]]]]],"^P","Builds a dispatcher which looks up a type by looking up the type itself,\n  then attempting to look up its ancestor classes, implemented interfaces, and\n  finally `java.lang.Object`."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"^P","Dispatch functions take a `Class` argument and return the looked-up value.\n  This provides similar functionality to Clojure's protocols, but operates over\n  locally-constructed logic rather than using a global dispatch table.\n\n  A simple example is a map from classes to values, which can be used directly\n  as a lookup function."]